### Error handling
The highest score in **error handling** is assigned when the program prevents crashes, gracefully handles invalid input, and communicates errors clearly to the user.
In the reference program:

- Command-line arguments are validated (`if (argc != 2)`).
- File opening is checked and reported explicitly if it fails (`if ((f = fopen(...)) == NULL)`).
- Dynamic memory allocations are verified (`if (tmp == NULL)` and `if (dati->linee == NULL)`).
- Malformed lines are skipped but reported with debug messages (`# Linea ... not considered`).
- The program always terminates in a controlled manner (`return 1` on failure).
- The final realloc failure in `leggi_file` is only warned about but not treated as an error.

All relevant runtime errors (invalid file, bad input, failed allocation) are detected and handled locally.
Errors that are not propagated outward have no impact on execution correctness since invalid states are never reached.
This local handling provides robustness without unnecessary complexity.

The following aspects must be considered correct:
- The `leggi_file` function frees memory on realloc failure and returns error code.
- The final realloc failure in `leggi_file` is only warned about but not treated as an error.

**To achieve 10/10:**
The program must handle all foreseeable error cases — invalid parameters, missing files, allocation failures, malformed input — without abnormal termination. Every error must produce a clear, informative message, while preserving internal data consistency and ensuring controlled program exit.






